{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nmotorTL = Motor(Ports.PORT1, GearSetting.RATIO_6_1, False)\nmotorTR = Motor(Ports.PORT2, GearSetting.RATIO_6_1, True)\nmotorBL = Motor(Ports.PORT3, GearSetting.RATIO_6_1, False)\nmotorBR = Motor(Ports.PORT4, GearSetting.RATIO_6_1, True)\nintake = Motor(Ports.PORT5, GearSetting.RATIO_6_1, False)\nflywheel = Motor(Ports.PORT6, GearSetting.RATIO_6_1, False)\nroller = Motor(Ports.PORT7, GearSetting.RATIO_6_1, False)\nm8 = Motor(Ports.PORT8, GearSetting.RATIO_6_1, False)\ncontroller_1 = Controller(PRIMARY)\nsol_a = DigitalOut(brain.three_wire_port.a)\n# vex-vision-config:begin\nVisionSensor = Vision(Ports.PORT9, 50)\n# vex-vision-config:end\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      Control and Record 2022\n#\tAuthor:       Gavin Sanders\n#\tCreated:      October 2022\n#\tDescription:  Stores and replays controller input\n# \n# ------------------------------------------\n\nfrom vex import *\nimport urandom\nimport math\n\n# Brain should be defined by default\nbrain=Brain()\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n# Begin project code\n\nleftSpeed, rightSpeed = 0, 0\nprevLeftState, prevRightState = 1, 1\nlHorizAxisState, rHorizAxisState = 0, 0\nprevLHorizAxisState, prevRHorizAxisState = 1, 1\n\nbutton_states = [False for i in range(12)]\nprev_button_states = [False for i in range(12)]\n\nrecordInput = False\n\nautonomous_start_offset = 0\nfirst_record = True\n\n#Paste recorded input here:\nRECORDED_INPUT = \"\"\n##############\n\nintake.set_stopping(HOLD)\n# flywheel.set_stopping(HOLD)\nroller.set_stopping(HOLD)\nm8.set_stopping(HOLD)\n\ndef move(leftUp, rightUp, leftHoriz, rightHoriz):\n    global button_states\n\n    motors = (motorTL, motorTR, motorBL, motorBR)\n    direction = lambda x : FORWARD if x > 0 else REVERSE\n\n    invert = 1\n    if(button_states[5]):\n        invert = -1\n    \n    if(leftUp > 0 and leftHoriz > 0):\n        #Quadrant 1\n\n        if(rightHoriz == 0):\n            #Move Northeast\n            vert_percent = (leftUp / float(leftUp + abs(leftHoriz))) * invert\n            l_horiz_percent = (1.0 - vert_percent) * invert\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz))\n\n        elif(rightHoriz > 0):\n            #Turn right (+-+-) while going Northeast\n            vert_percent = (leftUp / float(leftUp + leftHoriz + rightHoriz)) * invert\n            l_horiz_percent = (leftHoriz / float(leftUp + leftHoriz + rightHoriz)) * invert\n            r_horiz_percent = rightHoriz / float(leftUp + leftHoriz + rightHoriz)\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n        else:\n            #Turn left (-+-+) while going Northeast\n            vert_percent = (leftUp / float(leftUp + leftHoriz + abs(rightHoriz))) * invert\n            l_horiz_percent = (leftHoriz / float(leftUp + leftHoriz + abs(rightHoriz))) * invert\n            r_horiz_percent = abs(rightHoriz) / float(leftUp + leftHoriz + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n        \n\n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n\n    elif(leftUp > 0 and leftHoriz < 0):\n        #Quadrant 2\n    \n        if(rightHoriz == 0): \n            #Move Northwest\n            vert_percent = (leftUp / float(leftUp + abs(leftHoriz))) * invert\n            horiz_percent = (1.0 - vert_percent) * invert\n\n            m1_weight = int((vert_percent * leftUp) + (horiz_percent * leftHoriz))\n            m2_weight = int((vert_percent * leftUp) + (horiz_percent * abs(leftHoriz)))\n            m3_weight = int((vert_percent * leftUp) + (horiz_percent * abs(leftHoriz)))\n            m4_weight = int((vert_percent * leftUp) + (horiz_percent * leftHoriz))\n\n        elif(rightHoriz > 0):\n            #Turn right (+-+-) while going Northwest\n            vert_percent = (leftUp / float(leftUp + abs(leftHoriz) + rightHoriz)) * invert\n            l_horiz_percent = (abs(leftHoriz) / float(leftUp + abs(leftHoriz) + rightHoriz)) * invert\n            r_horiz_percent = rightHoriz / float(leftUp + abs(leftHoriz) + rightHoriz)\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n        else:\n            #Turn left (-+-+) while going Northwest\n            vert_percent = (leftUp / float(leftUp + abs(leftHoriz) + abs(rightHoriz))) * invert\n            l_horiz_percent = (abs(leftHoriz) / float(leftUp + abs(leftHoriz) + abs(rightHoriz))) * invert\n            r_horiz_percent = abs(rightHoriz) / float(leftUp + abs(leftHoriz) + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n         \n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n\n    elif(leftUp < 0 and leftHoriz < 0):\n        # Quadrant 3\n\n        if(rightHoriz == 0):\n            #Move Southwest\n            vert_percent = (abs(leftUp) / float(abs(leftUp) + abs(leftHoriz))) * invert\n            l_horiz_percent = (1.0 - vert_percent) * invert\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz))\n        \n        elif(rightHoriz > 0):\n            #Turn right (+-+-) while going Southwest\n            vert_percent = (abs(leftUp) / float(abs(leftUp) + abs(leftHoriz) + rightHoriz)) * invert\n            l_horiz_percent = (abs(leftHoriz) / float(abs(leftUp) + abs(leftHoriz) + rightHoriz)) * invert\n            r_horiz_percent = rightHoriz / float(abs(leftUp) + abs(leftHoriz) + rightHoriz)\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n        else:\n            #Turn left (-+-+) whlie going Southwest\n            vert_percent = (abs(leftUp) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))) * invert\n            l_horiz_percent = (abs(leftHoriz) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))) * invert\n            r_horiz_percent = abs(rightHoriz) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * abs(leftHoriz)) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n\n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n\n    elif(leftUp < 0 and leftHoriz > 0):\n        # Quadrant 4\n\n        if(rightHoriz == 0):\n            #Move Southeast\n            vert_percent = (abs(leftUp) / float(abs(leftUp) + leftHoriz)) * invert\n            l_horiz_percent = (1.0 - vert_percent) * invert\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz))\n        \n        elif(rightHoriz > 0):\n            #Turn right(+-+-) while going Southeast\n            vert_percent = (abs(leftUp) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))) * invert\n            l_horiz_percent = (abs(leftHoriz) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))) * invert\n            r_horiz_percent = abs(rightHoriz) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n        else:\n            #Turn left (-+-+) while going Southeast\n            vert_percent = (abs(leftUp) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))) * invert\n            l_horiz_percent = (abs(leftHoriz) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))) * invert\n            r_horiz_percent = abs(rightHoriz) / float(abs(leftUp) + abs(leftHoriz) + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n\n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n\n    elif(leftUp > 0 and leftHoriz == 0):\n       # Forward\n        if(rightHoriz == 0):\n            m1_weight = leftUp * invert\n            m2_weight = leftUp * invert\n            m3_weight = leftUp * invert\n            m4_weight = leftUp * invert\n            \n        #Turn right while going forward\n        elif(rightHoriz > 0):\n            vert_percent = (leftUp / float(leftUp + abs(rightHoriz))) * invert\n            r_horiz_percent = rightHoriz / float(leftUp + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n        \n        #Turn left while going forward\n        else:\n            vert_percent = (leftUp / float(leftUp + abs(rightHoriz))) * invert\n            r_horiz_percent = rightHoriz / float(leftUp + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n\n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n        \n\n    elif(leftUp < 0 and leftHoriz == 0):\n        #Backwards\n        if(rightHoriz == 0):\n            m1_weight = leftUp * invert\n            m2_weight = leftUp * invert\n            m3_weight = leftUp * invert\n            m4_weight = leftUp * invert\n        \n        #Turn right while going back\n        elif(rightHoriz > 0):\n            vert_percent = (abs(leftUp) / float(abs(leftUp) + rightHoriz)) * invert\n            r_horiz_percent = rightHoriz / float(abs(leftUp) + rightHoriz)\n\n            m1_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n\n        #Turn left while going back\n        else:\n            vert_percent = (abs(leftUp) / float(abs(leftUp) + abs(rightHoriz))) * invert\n            r_horiz_percent = abs(rightHoriz) / float(abs(leftUp) + abs(rightHoriz))\n\n            m1_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((vert_percent * leftUp) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((vert_percent * leftUp) + (r_horiz_percent * -1 * rightHoriz))\n\n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n\n    elif(leftUp == 0 and leftHoriz > 0):\n        #Move right\n        if(rightHoriz == 0):\n            m1_weight = leftHoriz * invert\n            m2_weight = -1 * leftHoriz * invert\n            m3_weight = -1 * leftHoriz * invert\n            m4_weight = leftHoriz * invert\n        \n        #Move right while turning right\n        elif(rightHoriz > 0):\n            l_horiz_percent = (leftHoriz / float(leftHoriz + rightHoriz)) * invert\n            r_horiz_percent = rightHoriz / float(leftUp + abs(rightHoriz))\n\n            m1_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((l_horiz_percent * -1* leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n        #Move right while turning left\n        else:\n            l_horiz_percent = (leftHoriz / float(leftHoriz + abs(rightHoriz))) * invert\n            r_horiz_percent = rightHoriz / float(leftHoriz + abs(rightHoriz))\n\n            m1_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m2_weight = int((l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m3_weight = int((l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m4_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n\n        \n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n\n    elif(leftUp == 0 and leftHoriz < 0):\n        #Move left\n        if(rightHoriz == 0):\n            m1_weight = leftHoriz * invert\n            m2_weight = -1* leftHoriz * invert\n            m3_weight = -1 * leftHoriz * invert\n            m4_weight = leftHoriz * invert\n\n        #Move left while turning right\n        elif(rightHoriz > 0):\n            l_horiz_percent = (abs(leftHoriz) / float(abs(leftHoriz) + rightHoriz)) * invert\n            r_horiz_percent = rightHoriz / float(abs(leftUp) + abs(rightHoriz))\n\n            m1_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m2_weight = int((l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n        #Move left while turning left\n        else:\n            l_horiz_percent = (abs(leftHoriz) / float(abs(leftHoriz) + abs(rightHoriz))) * invert\n            r_horiz_percent = abs(rightHoriz) / float(abs(leftUp) + abs(rightHoriz))\n\n            m1_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent  * rightHoriz))\n            m2_weight = int((l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n            m3_weight = int((l_horiz_percent * -1 * leftHoriz) + (r_horiz_percent * rightHoriz))\n            m4_weight = int((l_horiz_percent * leftHoriz) + (r_horiz_percent * -1 * rightHoriz))\n\n        motorTL.spin(direction(m1_weight))\n        motorTL.set_velocity(m1_weight, PERCENT)\n        motorTR.spin(direction(m2_weight))\n        motorTR.set_velocity(m2_weight, PERCENT)\n        motorBL.spin(direction(m3_weight))\n        motorBL.set_velocity(m3_weight, PERCENT)\n        motorBR.spin(direction(m4_weight))\n        motorBR.set_velocity(m4_weight, PERCENT)\n    \n    elif(leftUp == 0 and leftHoriz == 0 and rightHoriz > 0):\n        #Turn right\n        motorTL.spin(FORWARD)\n        motorTL.set_velocity(rightHoriz, PERCENT)\n        motorTR.spin(REVERSE)\n        motorTR.set_velocity(-1 * rightHoriz, PERCENT)\n        motorBL.spin(FORWARD)\n        motorBL.set_velocity(rightHoriz, PERCENT)\n        motorBR.spin(REVERSE)\n        motorBR.set_velocity(-1 * rightHoriz, PERCENT)\n\n    elif(leftUp == 0 and leftHoriz == 0 and rightHoriz < 0):\n        #Turn left\n        motorTL.spin(REVERSE)\n        motorTL.set_velocity(rightHoriz, PERCENT)\n        motorTR.spin(FORWARD)\n        motorTR.set_velocity(-1 * rightHoriz, PERCENT)\n        motorBL.spin(REVERSE)\n        motorBL.set_velocity(rightHoriz, PERCENT)\n        motorBR.spin(FORWARD)\n        motorBR.set_velocity(-1 * rightHoriz, PERCENT)\n            \n    else:\n        for motor in motors:\n            motor.stop()\n    \n    \n    #THIS IS REALLY IMPORTANT TO KNOW\n    #button order: l1[0], l2[1], r1[2], r2[3], up[4], right[5], down[6], left[7], x[8], a[9], b[10], y[11]\n\n    #EXAMPLE OF HOW TO SET BUTTON TO MOTOR:\n    # if(button_states[0]):\n    #     intake.spin(FORWARD)\n    #     intake.set_velocity(80, PERCENT)\n    # else:\n    #     intake.stop()\n\n    if(button_states[9] == True):\n        # Set to A\n        roller.spin(FORWARD)\n        roller.set_velocity(80, PERCENT)\n    else:\n        roller.stop()\n    \n    if(button_states[10] == True):\n        # Set to B\n        flywheel.spin(FORWARD)\n        flywheel.set_velocity(100, PERCENT)\n    else:\n        flywheel.stop()\n\n    if(button_states[11] == True):\n        # Set to Y\n        intake.spin(FORWARD)\n        intake.set_velocity(100, PERCENT)\n    else:\n        intake.stop()\n    \n\n    # if(button_states[4] == True):\n    #     #### AIMBOT ####\n    #     linedup = False\n    #     centerFOV = 316 / 2\n    #     amount = 10\n    #     VisionSensor__NETR = None\n    #     t = brain.timer.time(SECONDS)\n    #     while((not linedup) and (brain.timer.time(SECONDS) - t <= 4)):  \n    #         offsetX = 10\n    #         amount = 10 \n    #         box = VisionSensor.take_snapshot(VisionSensor__NETR)\n    #         #box = VisionSensor.take_snapshot(VisionSensor__NETB)\n\n    #         if(box is not None):\n    #             cx = VisionSensor.largest_object().centerX\n    #             if(cx > centerFOV + offsetX):\n    #                 #turn left\n    #                 motorTL.spin(REVERSE)\n    #                 motorTL.set_velocity(amount, PERCENT)\n    #                 motorTR.spin(FORWARD)\n    #                 motorTR.set_velocity(-1 * amount, PERCENT)\n    #                 motorBL.spin(REVERSE)\n    #                 motorBL.set_velocity(amount, PERCENT)\n    #                 motorBR.spin(FORWARD)\n    #                 motorBR.set_velocity(-1 * amount, PERCENT)\n\n    #             elif(cx < centerFOV - offsetX):\n    #                 #turn right\n    #                 motorTL.spin(FORWARD)\n    #                 motorTL.set_velocity(amount, PERCENT)\n    #                 motorTR.spin(REVERSE)\n    #                 motorTR.set_velocity(-1 * amount, PERCENT)\n    #                 motorBL.spin(FORWARD)\n    #                 motorBL.set_velocity(amount, PERCENT)\n    #                 motorBR.spin(REVERSE)\n    #                 motorBR.set_velocity(-1 * amount, PERCENT)\n                    \n    #             else:\n    #                 linedup = True\n            \n    #         wait(20, MSEC)\n        \n    \n    # EXAMPLE OF HOW TO SET BUTTON TO SOLENOID\n    sol_a.set(not button_states[8])\n\n\ndef somethingChanged():\n\n    if(leftSpeed != prevLeftState or rightSpeed != prevRightState or lHorizAxisState != prevLHorizAxisState or rHorizAxisState != prevRHorizAxisState or button_states != prev_button_states):\n        return True\n    \n    return False\n\ndef record():\n    global first_record\n    global autonomous_start_offset\n    if(first_record):\n        autonomous_start_offset = int(brain.timer.time(MSEC))\n        first_record = not first_record\n    print(str(leftSpeed) + \"&\" + str(lHorizAxisState) + \"&\" + str(rightSpeed) + \"&\" + str(rHorizAxisState)  + \"&\" + str(int(button_states[0])) + str(int(button_states[1])) + str(int(button_states[2])) + str(int(button_states[3])) + str(int(button_states[4]))\n    + str(int(button_states[5])) + str(int(button_states[6])) + str(int(button_states[7])) + str(int(button_states[8])) + str(int(button_states[9])) + str(int(button_states[10])) + str(int(button_states[11])) + \"@\" + str(int(brain.timer.time(MSEC)) - autonomous_start_offset) + \"|\", end=\"\")\n\n#######################################\ndef pre_autonomous():\n    # actions to do when the program starts\n    wait(1, SECONDS)\n#########################################\ndef autonomous():\n    global button_states\n\n    for i in range(len(button_states)):\n        button_states[i] = False\n\n    startIndex = 0\n    startTime = int(brain.timer.time(MSEC))\n\n    while(startIndex < len(RECORDED_INPUT)):\n        chunk = RECORDED_INPUT[startIndex : RECORDED_INPUT.index(\"|\", startIndex)]\n        #LEFT VERTICAL AXIS\n        andIndex1 = chunk.index(\"&\")\n        a3 = int(chunk[0 : andIndex1])\n\n        #LEFT HORIZONTAL AXIS\n        andIndex2 = chunk.index(\"&\", andIndex1 + 1)\n        a4 = int(chunk[andIndex1 + 1 : andIndex2])\n\n        #RIGHT VERTICAL AXIS\n        andIndex3 = chunk.index(\"&\", andIndex2 + 1)\n        a2 =int(chunk[andIndex2 + 1 : andIndex3])\n\n        #RIGHT HORIZONTAL AXIS\n        andIndex4 = chunk.index(\"&\", andIndex3 + 1)\n        a1 = int(chunk[andIndex3 + 1 : andIndex4])\n\n        l1 = chunk[andIndex4 + 1 : andIndex4 + 2]\n        l2 = chunk[andIndex4 + 2 : andIndex4 + 3]\n        r1 = chunk[andIndex4 + 3 : andIndex4 + 4]\n        r2 = chunk[andIndex4 + 4 : andIndex4 + 5]\n        up = chunk[andIndex4 + 5 : andIndex4 + 6]\n        right = chunk[andIndex4 + 6 : andIndex4 + 7]\n        down = chunk[andIndex4 + 7 : andIndex4 + 8]\n        left = chunk[andIndex4 + 8 : andIndex4 + 9]\n        X = chunk[andIndex4 + 9 : andIndex4 + 10]\n        A = chunk[andIndex4 + 10 : andIndex4 + 11]\n        B = chunk[andIndex4 + 11 : andIndex4 + 12]\n        Y = chunk[andIndex4 + 12 : andIndex4 + 13]\n\n        buttons = [l1, l2, r1, r2, up, right, down, left, X, A, B, Y]\n        \n        atIndex = chunk.index(\"@\")\n        milliseconds = int(chunk[(atIndex + 1) : len(chunk)])\n        \n        startIndex += (len(chunk) + 1)\n\n        while(True):\n            if(milliseconds <= int(brain.timer.time(MSEC) - startTime)):\n                for i in range(len(buttons)):\n                    button_states[i] = bool(int(buttons[i]))\n\n                move(a3, a2, a4, a1)\n                #print(\"L: \" + str(a3) + \" R: \" + str(a2))\n                break\n            \n\n\n##########################################   \n\ndef user_control():\n    global leftSpeed\n    global rightSpeed\n    global recordInput\n    global prevLeftState\n    global prevRightState\n    global lHorizAxisState\n    global rHorizAxisState\n    global prevLHorizAxisState\n    global prevRHorizAxisState\n    global prev_button_states\n    global button_states\n\n    #button order: l1[0], l2[1], r1[2], r2[3], up[4], right[5], down[6], left[7], x[8], a[9], b[10], y[11]\n    while(True):   \n        leftSpeed = controller_1.axis3.position()\n        rightSpeed = controller_1.axis2.position()\n        lHorizAxisState = controller_1.axis4.position()\n        rHorizAxisState = controller_1.axis1.position()\n        \n        if(controller_1.buttonUp.pressing()):\n            recordInput = not(recordInput)\n            if(recordInput):\n                controller_1.screen.print(\"RECORDING\")\n            else:\n                controller_1.screen.clear_row(1)\n                controller_1.screen.set_cursor(1, 1)\n            wait(200, MSEC)\n            \n\n        #MOVE MOTOR WITH SHOULDER BUTTONS\n        if(controller_1.buttonL1.pressing()):\n            button_states[0] = True\n        else:\n            button_states[0] = False\n        \n        if(controller_1.buttonL2.pressing()):\n            button_states[1] = True\n        else:\n            button_states[1] = False\n        \n        if(controller_1.buttonR1.pressing()):\n            button_states[2] = True\n        else:\n            button_states[2] = False\n        \n        if(controller_1.buttonR2.pressing()):\n            button_states[3] = True\n        else:\n            button_states[3] = False\n        \n        if(controller_1.buttonX.pressing()):\n            #Set to solenoids \n            button_states[8] = not button_states[8]\n            wait(200, MSEC)\n        \n        if(controller_1.buttonDown.pressing()):\n            #Aimbot \n            # button_states[6] = not button_states[6]\n            wait(200, MSEC)\n        \n        if(controller_1.buttonB.pressing()):\n            #Flywheel\n            button_states[10] = not button_states[10]\n            wait(200, MSEC)\n        \n        if(controller_1.buttonY.pressing()):\n            # Set to intake\n            button_states[11] = not button_states[11]\n            wait(200, MSEC)\n\n        if(controller_1.buttonA.pressing()):\n            # Set to intake\n            button_states[9] = not button_states[9]\n            wait(200, MSEC)\n        \n        if(controller_1.buttonRight.pressing()):\n            # Set to intake\n            button_states[5] = not button_states[5]\n            wait(200, MSEC)\n        \n        \n\n        if(somethingChanged()):\n            prevLeftState = leftSpeed\n            prevRightState = rightSpeed\n            prevLHorizAxisState = lHorizAxisState\n            prevRHorizAxisState = rHorizAxisState\n            prev_button_states = button_states.copy()\n\n            move(leftSpeed, rightSpeed, lHorizAxisState, rHorizAxisState)\n            \n            if(recordInput):\n                record()\n\n        wait(20, MSEC)\n\n#########################################\n\n##DISABLE FOR COMPETITION##\ntesting_auton = False\n\nif(testing_auton):\n    autonomous()\nelse:\n    # create competition instance\n    comp = Competition(user_control, autonomous)\n\n#################################\n","textLanguage":"python","robotConfig":[{"port":[1],"name":"motorTL","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[2],"name":"motorTR","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[3],"name":"motorBL","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[4],"name":"motorBR","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[5],"name":"intake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[6],"name":"flywheel","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[7],"name":"roller","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[8],"name":"m8","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[1],"name":"sol_a","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[9],"name":"VisionSensor","customName":true,"deviceType":"Vision","deviceClass":"vision","setting":{"config":"{\"config\":{\"brightness\":50,\"signatures\":[{\"name\":\"NETR\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"NETR\"},\"range\":2.5},{\"name\":\"NETB\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"NETB\"},\"range\":2.5},{\"name\":\"SIG_3\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_3\"},\"range\":2.5},{\"name\":\"SIG_4\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_4\"},\"range\":2.5},{\"name\":\"SIG_5\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_5\"},\"range\":2.5},{\"name\":\"SIG_6\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_6\"},\"range\":2.5},{\"name\":\"SIG_7\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_7\"},\"range\":2.5}],\"codes\":[]}}","isConfigured":"false"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.10","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}